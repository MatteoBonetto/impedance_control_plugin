/*
  _____ _ _ _                    _             _
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/
# A Template for Impedance_controlPlugin, a Filter Plugin
# Generated by the command: plugin --type filter --dir impedance_control_plugin
--install-dir /usr/local impedance_control -o # Hostname: raspberrypi # Current
working directory: /home/miro/repo/mads/develop # Creation date:
2025-08-06T17:16:55.984+0200 # NOTICE: MADS Version 1.3.1
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
// other includes as needed here
#include "ImpedanceControlManager.h"
#include <fstream>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "impedance_control"
#endif

// Load the namespaces
using namespace common_walker;
using namespace std;
using json = nlohmann::json;

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Impedance_controlPlugin : public Filter<json, json> {

public:
  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    try {
      if (topic == "ego_state") {
        _mode = input.value<modes>("fsm_mode", unknown_mode);
        // to remove
        _mode = impedance_control_mode;
        if (input.contains("ego_state")) {
          for (const auto &[key, signal] :
               _impedance_control_manager->ego_state_map) {
            double value = input["ego_state"].value<double>(key, 0.0);
            double time_interval =
                input["ego_state"].value<double>("time_interval", -1.0);

            double timecode = signal.timecode();
            if (timecode == -1.0 || time_interval == -1.0) {
              _impedance_control_manager->ego_state_map[key].update(
                  std::make_tuple(0.0, value));
            } else {
              _impedance_control_manager->ego_state_map[key].update(
                  std::make_tuple(timecode + time_interval, value));
            }
          }
          _impedance_control_manager->time_interval =
              input["ego_state"].value<double>("time_interval", -1.0);
        }
      } else if (topic == "mqtt2mads") {
        std::cout << "mqtt2mads" << std::endl;
        // CHECK WHETHER incipit arrived on mqtt
        if (input.contains("payload") && input["payload"].contains("incipit")) {
          _impedance_control_manager->incipit_param.incipit_function =
              _incipit_function_map[(input["payload"].value<string>(
                  "incipit_function", "decrease_linearly_with_velocity"))];
          _impedance_control_manager->incipit_param.v_considered_as_moving =
              input["payload"].value<double>("v_considered_as_moving", 0.2);
          _impedance_control_manager->incipit_param.incipit_parameter =
              input["payload"].value<double>("incipit_parameter", 5);
          _impedance_control_manager->incipit_param.F0_max =
              input["payload"].value<double>("F0_max", 40.0);
          _impedance_control_manager->incipit_param.g =
              input["payload"].value<double>("g", 1.0);
        }
        // CHECK WHETHER delta_theta arrived on mqtt
        if (input.contains("payload") &&
            input["payload"].contains("delta_theta")) {
          _impedance_control_manager->delta_theta_f =
              _delta_theta_function_map[(input["payload"].value<string>(
                  "delta_theta_function", "none"))];
        }
        // CHECK WHETHER impedence params arrived on mqtt
        if (input.contains("payload") &&
            input["payload"].contains("impedance_params")) {
          std::cout << "message arrived" << std::endl;
          _impedance_control_manager->impedance_params.M_v =
              input["payload"]["impedance_params"].value<double>("M_v", 0.0);
          _impedance_control_manager->impedance_params.M_w =
              input["payload"]["impedance_params"].value<double>("M_w", 0.0);
          _impedance_control_manager->impedance_params.C_v =
              input["payload"]["impedance_params"].value<double>("C_v", 0.0);
          _impedance_control_manager->impedance_params.C_w =
              input["payload"]["impedance_params"].value<double>("C_w", 0.0);
          _impedance_control_manager->impedance_params.K_v =
              input["payload"]["impedance_params"].value<double>("K_v", 0.0);
          _impedance_control_manager->impedance_params.K_w =
              input["payload"]["impedance_params"].value<double>("K_w", 0.0);
        }
      }
    } catch (json::parse_error &e) {
      _error = e.what();
      std::cerr << "JSON parse error: " << _error << std::endl;
      return return_type::retry;
    } catch (json::type_error &e) {
      _error = e.what();
      std::cerr << "JSON parse error: " << _error << std::endl;
      return return_type::retry;
    }
    return return_type::success;
  }

  // We calculate the average of the last N values for each key and store it
  // into the output json object
  return_type process(json &out) override {
    out.clear();

    if (_mode == impedance_control_mode) {
      // Call the compute_incipit method of the ImpedanceControlManager
      return_type result = _impedance_control_manager->compute_incipit();
      if (result != return_type::success) {
        std::cerr << "Error computing incipit" << std::endl;
        return result;
      }
      result = _impedance_control_manager->compute_impedance_control();
      if (result != return_type::success) {
        std::cerr << "Error computing impedance control" << std::endl;
        return result;
      }

      out = {{"mode", "torque"},
             {"sp",
              {{"sx", _impedance_control_manager->left_wheel_torque()},
               {"dx", _impedance_control_manager->right_wheel_torque()}}}};
    }

    if (!_agent_id.empty())
      out["agent_id"] = _agent_id;
    return return_type::success;
  }

  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters
    // (e.g. agent_id, etc.)
    Filter::set_params(params);

    double wheel_radius = _params.value("wheel_radius", 0.0);
    double wheel_base = _params.value("wheel_base", 0.0);
    double walker_mass = _params.value("walker_mass", 0.0);
    double wheel_mass = _params.value("wheel_mass", 0.0);
    double I_wheel = wheel_mass * wheel_radius * wheel_radius;
    double I_body = _params.value("I_body", 0.0);
    walker_phisical_parameter walker_params;
    walker_params.wheel_base = wheel_base;
    walker_params.wheel_radius = wheel_radius;
    walker_params.walker_mass = walker_mass;
    walker_params.wheel_mass = wheel_mass;
    walker_params.I_wheel = I_wheel;
    walker_params.I_body = I_body;

    // Initialize the ImpedanceControlManager with the parameters
    _impedance_control_manager =
        make_unique<ImpedanceControlManager>(walker_params);

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(*(json *)params);
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override {
    // return a map of stringswith additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    return {};
  };

private:
  unique_ptr<ImpedanceControlManager> _impedance_control_manager;

  modes _mode = unknown_mode;
  map<std::string, incipit_function_start_moving> _incipit_function_map = {
      {"none_incipit", none_incipit},
      {"decrease_linearly_with_velocity", decrease_linearly_with_velocity},
      {"decrease_exponentialy_with_time", decrease_exponentialy_with_time}};

  map<std::string, delta_theta_function> _delta_theta_function_map = {
      {"none", none}, {"atan", atan_function}, {"sqrt", sqrt_function}};
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Impedance_controlPlugin, json, json);

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

*/
#include <unistd.h> // Per sleep()
int main(int argc, char const *argv[]) {
  Impedance_controlPlugin plugin;
  json params;
  json input, output;

  try {

    ifstream file_params("params.json");
    if (!file_params.is_open()) {
      cerr << "Impossible to open file!" << endl;
      return 1;
    }

    file_params >> params;
    file_params.close();

    ifstream file_input("input.json");
    if (!file_input.is_open()) {
      cerr << "Impossible to open file!" << endl;
      return 1;
    }

    file_input >> input;
    file_input.close();

    // Set the parameters
    plugin.set_params(&params);

    while (1) {
      sleep(1);
      if (plugin.load_data(input, "encoders") != return_type::success) {
        cout << "Error: " << plugin.error() << endl;
        continue;
      }
      if (plugin.process(output) == return_type::success) {
        cout << "Output: " << output << endl;
        continue;
      }
    }

  } catch (exception &e) {
    cerr << e.what() << endl;
    return 1;
  }

  return 0;
}
