/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Impedance_controlPlugin, a Filter Plugin
# Generated by the command: plugin --type filter --dir impedance_control_plugin --install-dir /usr/local impedance_control -o
# Hostname: raspberrypi
# Current working directory: /home/miro/repo/mads/develop
# Creation date: 2025-08-06T17:16:55.984+0200
# NOTICE: MADS Version 1.3.1
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
// other includes as needed here
#include <fstream>
#include "ImpedanceControlManager.h"

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "impedance_control"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Impedance_controlPlugin : public Filter<json, json> {

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    try {
      if (topic == "ego_state") {
        _mode = _modes_map[(input.value("fsm_mode", "unknown_mode"))];
        _ego_state.x = input["incipit"].value("x", 0.0);
        _ego_state.y = input["incipit"].value("y", 0.0);
        _ego_state.theta = input["incipit"].value("theta", 0.0);
        _ego_state.speed = input["incipit"].value("speed", 0.0);
        _ego_state.angular_speed = input["incipit"].value("angular_speed", 0.0);
        _ego_state.acceleration = input["incipit"].value("acceleration", 0.0);
        _ego_state.angular_acceleration = input["incipit"].value("angular_acceleration", 0.0);
        _ego_state.k_theta_ref = input["incipit"].value("k_theta_ref", 0.0);
        _ego_state.k_delta_ref = input["incipit"].value("k_delta_ref", 0.0);
        _ego_state.time_interval = input["incipit"].value("time_interval", 0.0);

        _impedance_control_manager->ego_state = _ego_state;

      } else if (topic == "incipit") {
        _incipit_parameters.incipit_function = _incipit_function_map[(input.value("incipit_function", "none"))];
        _incipit_parameters._v_considered_as_moving = input.value("v_considered_as_moving", 0.0);
        _incipit_parameters._incipit_parameter = input.value("incipit_parameter", 0.0);
        _incipit_parameters._F0_max = input.value("F0_max", 0.0);

        _impedance_control_manager->set_incipit_parameters(_incipit_parameters);
      } else if (topic == "loadcells") {

      }
    } catch (json::parse_error &e) {
      _error = e.what();
      return return_type::retry;
    } catch (json::type_error &e) {
      _error = e.what();
      return return_type::retry;
    }
    return return_type::success;
  }

  // We calculate the average of the last N values for each key and store it
  // into the output json object
  return_type process(json &out) override {
    out.clear();
    return_type result = return_type::critical;

    if (_mode == impedance_control_mode) {
      // Call the compute_incipit method of the ImpedanceControlManager
      result = _impedance_control_manager->compute_incipit();
      if (result != return_type::success) {
        std::cerr << "Error computing incipit" << std::endl;
        return result;
      }
      result = _impedance_control_manager->compute_impedance_control();
      if (result != return_type::success) {
        std::cerr << "Error computing incipit" << std::endl;
        return result;
      }
      out = {
          {"mode", "torque"},
          {"sp", {
              {"sx", _impedance_control_manager->left_wheel_torque()},
              {"dx", _impedance_control_manager->right_wheel_torque()}
          }}
      };
    } else if (_mode == unknown_mode) {
      _error = "Mode not set or unknown.";
      return return_type::error;
    } else if (_mode == unsupported_mode) {
      _error = "Unsupported mode.";
      return return_type::critical;
    }

    if (!_agent_id.empty()) out["agent_id"] = _agent_id;
    return return_type::success;
  }
  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters
    // (e.g. agent_id, etc.)
    Filter::set_params(params);

    double wheel_radius = _params.value("wheel_radius", 0.0);
    double wheel_base = _params.value("wheel_base", 0.0);
    double g = _params.value("g", 1.0);

    // Initialize the ImpedanceControlManager with the parameters
    _impedance_control_manager =
        make_unique<ImpedanceControlManager>(wheel_radius, wheel_base, g);

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(*(json *)params);
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of stringswith additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    return {}; 
  };

private:
  unique_ptr<ImpedanceControlManager> _impedance_control_manager;

  modes _mode = unknown_mode;
  map<std::string, modes> _modes_map = {
    {"impedance_control_mode", impedance_control_mode},
    {"joystick_control_mode", joystick_control_mode},
    {"emergency_control_mode", emrgency_control_mode},
    {"set_reference_mode", set_reference_mode},
    {"unknown_mode", unknown_mode}};
  ego_state_estimation _ego_state;

  incipit_parameters _incipit_parameters;
  map<std::string, incipit_function_start_moving> _incipit_function_map = {
    {"none", none},
    {"decrease_linearly_with_velocity", decrease_linearly_with_velocity},
    {"decrease_exponentialy_with_time", decrease_exponentialy_with_time}
  };

};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Impedance_controlPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/
#include <unistd.h> // Per sleep()
int main(int argc, char const *argv[])
{
  Impedance_controlPlugin plugin;
  json params;
  json input, output;

  try {

    ifstream file_params("params.json");
    if (!file_params.is_open()) {
      cerr << "Impossible to open file!" << endl;
      return 1;
    }

    file_params >> params;
    file_params.close();

    ifstream file_input("input.json");
    if (!file_input.is_open()) {
      cerr << "Impossible to open file!" << endl;
      return 1;
    }

    file_input >> input;
    file_input.close();

    // Set the parameters
    plugin.set_params(&params);

    while (1) {
      sleep(1);
      if (plugin.load_data(input, "encoders") != return_type::success) {
        cout << "Error: " << plugin.error() << endl;
        continue;
      }
      if (plugin.process(output) == return_type::success) {
        cout << "Output: " << output << endl;
        continue;
      }
      
    }

  } catch (exception &e) {
    cerr << e.what() << endl;
    return 1;
  }

  return 0;
}

